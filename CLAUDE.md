# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**Journal by Early Bird** is a local-first, privacy-focused journaling web application. The core philosophy: each entry is an immutable snapshot in time to encourage authentic self-expression without self-censorship. Instead of editing entries, users can reflect on them later by adding comments.

All data is stored client-side in IndexedDB with no server-side persistence, ensuring complete privacy.

## Development Commands

```bash
bun dev          # Start Vite development server at localhost:5173
bun run build    # Build for production with Vite (outputs to /dist)
bun start        # Run Vite preview server for production build
bun test         # Run all tests with Bun test runner
bun check        # Lint and format code with Biome
```

## Architecture

- **Package Manager**: Bun (for package management and script execution)
- **Dev Server & Build**: Vite (Rolldown variant) with React plugin
- **Frontend**: React 19 + TypeScript
- **Routing**: TanStack Router with auto code-splitting
- **Database**: Starling ORM with IndexedDB plugin
- **Styling**: Tailwind CSS 4 with custom theme
- **Validation**: Zod schemas
- **Code Quality**: Biome (linting & formatting)
- **Testing**: Bun test runner
- **PWA**: vite-plugin-pwa for Progressive Web App capabilities

## Build System

The project uses **Vite** (Rolldown variant) for development and production builds:

- **Development**: Vite dev server with Hot Module Replacement (HMR) and React Fast Refresh
- **Production**: Optimized builds with code splitting and minification
- **Entry Point**: `index.html` at project root imports `/src/main.tsx`
- **Static Assets**: Served from `public/` directory

### Vite Configuration

Configuration in `vite.config.ts`:
- **TanStack Router Plugin**: Auto code-splitting, routes in `./src/app/routes`
- **React Plugin**: `@vitejs/plugin-react` for Fast Refresh
- **Path Alias**: `@/*` maps to `./src/*` for cleaner imports
- **Tailwind CSS 4**: Automatically processed via PostCSS
- **PWA Plugin**: Progressive Web App with service worker, auto-update, offline support

### Tailwind CSS 4

The project uses Tailwind CSS 4 with custom theme variables defined in `src/app.css`:

```css
@import "tailwindcss";

@theme {
  --color-*: initial;
  --color-black: #171717;
  --color-yellow: #ffca67;
  /* ... */
}
```

Vite natively supports Tailwind CSS 4 imports - no additional configuration needed.

## Database & Data Layer

The application uses **Starling** ORM with the IndexedDB plugin for client-side data persistence.

### Schema

Three core entities defined with Zod in `src/lib/db/schema.ts`:

**Note** (`noteSchema`):
- `id`: UUID (auto-generated)
- `content`: String
- `createdAt`: ISO 8601 timestamp (auto-set)

**Task** (`taskSchema`):
- `id`: UUID (auto-generated)
- `content`: String
- `status`: Literal ["incomplete", "complete", "deferred"] (default: "incomplete")
- `createdAt`: ISO 8601 timestamp (auto-set)

**Comment** (`commentSchema`):
- `id`: UUID (auto-generated)
- `entryId`: UUID (references Note or Task)
- `content`: String
- `createdAt`: ISO 8601 timestamp (auto-set)

**Entry Type**: Discriminated union combining Note and Task:
```ts
type Entry = (Note & { type: "note" }) | (Task & { type: "task" });
```

### Database Setup

Database initialization in `src/lib/db/db.ts`:
```ts
export const db = createDatabase({
  name: "journal",
  version: 1,
  schema: {
    notes: { schema: noteSchema, getId: (note) => note.id },
    tasks: { schema: taskSchema, getId: (task) => task.id },
    comments: { schema: commentSchema, getId: (comment) => comment.id },
  },
}).use(idbPlugin());
```

**Database Provider**: The `DbProvider` component in `src/app/providers/db-provider.tsx` initializes the database asynchronously before rendering children. Wrap your app root with this provider.

### Custom Hooks & Utilities

**Query Hook** (`src/lib/hooks/use-query.tsx`):
- **`useQuery<T>(queryFn, deps)`** - Creates reactive queries that auto-update when data changes. Returns results synchronously (never undefined). Handles subscription lifecycle automatically.

**Resource Hooks** (`src/features/journal/resources/`):
- **`useEntriesQuery(date?)`** - Fetches entries (notes + tasks) with comments. Optional ISO date filter. Returns combined Entry[] with comments attached.

**Utility Hooks** (`src/lib/hooks/`):
- **`useDateNow()`** - Tracks current date, updates at midnight
- **`useKeyboardHeightCssVar()`** - Detects mobile virtual keyboard height, sets CSS variables for safe areas

## Routing

The application uses **TanStack Router** with file-based routing:

- **Routes Directory**: `src/app/routes/`
- **Root Route**: `__root.tsx` - Wraps all routes with `DbProvider`, renders `Outlet` for child routes
- **Generated Route Tree**: `src/routeTree.gen.ts` - Auto-generated by `@tanstack/router-plugin`
- **Auto Code-Splitting**: Enabled via router plugin configuration
- **View Transitions**: Supported via `viewTransition` prop on Link components

Example route structure:
```
src/app/routes/
  __root.tsx      # Root layout with DbProvider
  index.tsx       # Home route (/)
  settings.tsx    # Settings route (/settings)
```

## Component Organization

Components follow a feature-based structure:

- **`/src/components/layout/`** - Layout components (nav-bar, page)
- **`/src/components/ui/`** - Generic UI components (button, drawer, textarea)
- **`/src/features/journal/components/`** - Journal-specific components (entry creators, lists, detail dialogs, comments)
- **`/src/features/data/`** - Data import/export functionality
- **`/src/app/routes/`** - TanStack Router route components

All components use the compound component pattern (see Design Patterns section).

## Design Patterns

### Compound Components

Use the compound component pattern for organizing related UI components. Group components as properties of a single exported object using dot notation:

```tsx
const Root = (props: ComponentProps<"div">) => (
  <div {...props} className={cx("base-styles", props.className)} />
);

const Header = (props: ComponentProps<"header">) => (
  <header {...props} className={cx("header-styles", props.className)} />
);

const Content = (props: ComponentProps<"main">) => (
  <main {...props} className={cx("content-styles", props.className)} />
);

export const Layout = {
  Root,
  Header,
  Content,
};
```

Usage:
```tsx
<Layout.Root>
  <Layout.Header>Header content</Layout.Header>
  <Layout.Content>Main content</Layout.Content>
</Layout.Root>
```

Benefits:
- Clear component relationships and hierarchy
- Better discoverability via IDE autocomplete
- Avoids namespace pollution
- Flexible composition while maintaining semantic structure

#### Internal Compound Components

For components that capture business logic, use internal compound components. Keep the compound structure for code organization but export a single assembled component:

```tsx
const Root = (props: ComponentProps<"article">) => (
  <article {...props} className={cx("base-styles", props.className)} />
);

const Header = (props: ComponentProps<"header">) => (
  <header {...props} className={cx("header-styles", props.className)} />
);

const Content = (props: ComponentProps<"div">) => (
  <div {...props} className={cx("content-styles", props.className)} />
);

export const EntryCard = (props: { entry: Entry }) => {
  return (
    <Root>
      <Header>{entry.title}</Header>
      <Content>{entry.content}</Content>
    </Root>
  );
};
```

This pattern provides internal organization benefits while keeping a simple public API for consumers.

**Note**: Don't over-engineer compound components. Use vanilla HTML elements when they don't need styling, logic, or props forwarding. Only create compound components when they add meaningful value through styling, behavior, or semantic structure.

## File Naming

All files and directories should use lowercase and kebab-case naming:

- **Files**: `user-profile.tsx`, `data-menu.tsx`, `entry-list.stories.tsx`
- **Directories**: `entry-comment-item/`, `shared/`, `layouts/`
- **Components**: Export names remain PascalCase (e.g., `UserProfile`, `DataMenu`) but files are kebab-case

Examples:
```
✅ Good:
- components/user-profile/user-profile.tsx
- components/data-menu/data-menu.stories.tsx
- layouts/aside-layout.tsx

❌ Avoid:
- components/UserProfile/UserProfile.tsx
- components/DataMenu/DataMenu.stories.tsx
- layouts/AsideLayout.tsx
```

This convention:
- Ensures consistency across the codebase
- Avoids case-sensitivity issues on different filesystems
- Improves readability and maintainability
- Follows modern web development best practices

## Code Style

### TypeScript

- NEVER use `any` type. Always use proper TypeScript types.
- Prefer explicit typing over type inference when it improves code clarity.

### Type vs Interface

Prefer `type` over `interface` for type definitions.

```ts
// Preferred: type
type DataMenuProps = {
	onExport?: () => void;
	onImport?: () => void;
};

// Avoid: interface
interface DataMenuProps {
	onExport?: () => void;
	onImport?: () => void;
}
```

### Guard Clauses

Prefer guard clauses with early returns over nested if-else statements. This improves readability and reduces cognitive load.

```ts
// Preferred: Guard clauses
function processData(input: unknown) {
  if (!input) {
    console.error("No input provided");
    return undefined;
  }

  if (typeof input !== "string") {
    console.error("Input must be a string");
    return undefined;
  }

  // Happy path logic here
  return input.toUpperCase();
}

// Avoid: Nested conditions
function processData(input: unknown) {
  if (input) {
    if (typeof input === "string") {
      // Happy path logic here
      return input.toUpperCase();
    } else {
      console.error("Input must be a string");
      return undefined;
    }
  } else {
    console.error("No input provided");
    return undefined;
  }
}
```

## Testing

The project uses **Bun's built-in test runner** for testing:

**Running Tests:**
```bash
bun test                    # Run all tests
bun test path/to/file.test.ts   # Run specific test file
```

**Test Structure:**
- Test files use `.test.ts` or `.test.tsx` extension
- Import test utilities from `bun:test`: `import { test, expect } from "bun:test"`
- Tests are located alongside source files (e.g., `extract.ts` → `extract.test.ts`)

**Example Test:**
```ts
import { expect, test } from "bun:test";

test("extractNotes - validates and extracts valid notes", () => {
  const data = { notes: { data: [...] } };
  const result = extractNotes(data);
  expect(result.valid).toHaveLength(1);
});
```

**Current Test Coverage:**
- Data import utilities (`src/lib/utils/import/*.test.ts`)
  - `extract.test.ts` - JSON:API data extraction
  - `parse.test.ts` - File parsing
  - `validate.test.ts` - Schema validation
